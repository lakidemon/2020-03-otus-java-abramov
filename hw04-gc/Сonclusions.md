# Сравнение сборщиков мусора Java
## Условия тестирования
Объём нагрузок подбирался под каждый объём кучи отдельно так, чтобы время выполнения было близко к 5 минутам.
За эталон бралось время выполнения с Epsilon GC, т.е. без сборок мусора как таковых.
Информация о сборках и времени работы записывалась в csv файл.
#### Система:
* Windows 10 1909
* OpenJDK 11.0.6+8-b520.43
* CPU: AMD Ryzen 1600X 6C/12T
* RAM: 16GB

#### Параметры JVM:

     -Xmx256M || -Xmx1G || -Xmx4G
     -Xms256M || -Xms1G || -Xms4G
     -XX:+UseSerialGC || -XX:+UseParallelGC  || -XX:+UseG1GC
     -XX:+ExitOnOutOfMemoryError

------------
## Обобщённые результаты запусков
|         |Без GC, сек||
|---------|:---:|-----|
| 256M    | 1G  | 4G  |
| 296     | 306 | 305 |

| ﻿                          |        |    G1  |         |          |Parallel|         |        | Serial |         |
|---------------------------|--------|--------|---------|----------|--------|---------|--------|--------|---------|
| Значение Xmx              |**256M**| **1G** | **4G**  | **256M** | **1G** | **4G**  |**256M**| **1G** | **4G**  |
| Время выполнения, сек.    | 698    | 681    | 757     | 562      | 663    | 803     | 693    | 701    | 801     |
| Отличие от эталона, %     | 235,8% | 222,5% | 248,2%  | 189,9%   | 216,7% | 263,3%  | 234,1% | 229,1% | 262,6%  |
| Minor сборки, мин. мсек.  | 3      | 2      | 8       | 91       | 614    | 2984    | 49     | 211    | 833     |
| Minor сборки, макс. мсек. | 406    | 385    | 1584    | 265      | 1597   | 6681    | 118    | 484    | 1982    |
| Major сборки, мин. мсек.  | 262    | 1214   | 4977    | 344      | 2168   | 9483    | 228    | 972    | 3920    |
| Major сборки, макс. мсек. | 348    | 1614   | 5686    | 708      | 6664   | 25514   | 439    | 1764   | 7046    |
| Общее время STW, сек.     | 7,049  | 40,223 | 152,397 | 7,357    | 79,361 | 308,411 | 13,605 | 60,248 | 242,244 |
| Доля времени STW, %       | 1,01%  | 5,91%  | 20,13%  | 1,31%    | 11,97% | 38,41%  | 1,96%  | 8,59%  | 30,24%  |

## Выводы
G1 GC можно считать оптимальным сборщиком для среднестатистического приложения среди представленных, если пропускная способность не в приоритете.
Периодические малые сборки позволяют избегать долгих остановок приложения, хотя по мере разрастания кучи на сборки уходит всё больше ресурсов процессора.

Serial GC проводит сборки намного реже G1, хоть и дольше, но зато по минимуму нагружая процессор.
Сейчас этот сборщик подойдёт только для каких-то специфических кейсов, либо при работе на маломощном оборудовании, где распараллеливание процессов сборки приведёт только к ухудшению производительности. 

Parallel GC по поведению выглядит как Serial, только многопоточный и с различными улучшениями, направленными на повышение эффективности.
Вдобавок, он не пытается очищать память, когда затраченные ресурсы на сборку не приносят ощутимого результата, а вылетает с OOM gc overhead limit exceeded.
В данном тестировании этот сборщик показал себя не лучшим образом, зависая на очень долгое время под конец выполнения программы.
Очевидно, что данный сборщик требует явного указания числа доступных ему потоков(что справедливо и для G1), т.к. пытаясь использовать все имеющиеся, он лишь ухудшает собственную производительность.
Однако в реальных условиях и при грамотной настройке он может быть предпочтительнее G1 ввиду более редких пауз, обеспечивая большую пропускную способность.
